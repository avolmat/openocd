# SPDX-License-Identifier: GPL-2.0-or-later

# STMicroelectronics STiH418 SOC (Quad Cortex-A9)
# Behavior understood by readying code found within the package targetpack on 4kopen.com
# Cf boards_ng/b2264stxh418/stxh418.py, boards_ng/b2199stxh418/stxh418_g4soc.py

# Enable debug messages
set DEBUG_PRINT	0
set DEBUG_PRINT_LOW	0

# Mapping chain ctrl (DBU)
set DBU_IDCODE		0x24103D03
set DBU_DBU		2
set DBU_SWITCHABLE	8

# Mapping chain ctrl (DBU_SA)
set DBU_SA_IDCODE	0x18400D03
set DBU_SA_DBU_SA	1
set DBU_SA_A9		0x10

# Helper function to read a register within a DBU
proc read_dbu_reg { tap addr } {
	irscan $tap 0x05
	drscan $tap 40 [expr "$addr | 0x02"]
	set tapreg [drscan $tap 40 0]
	set ret [expr "0x$tapreg >> 8"]
	if { $::DEBUG_PRINT_LOW == 1 } {
		echo "read_dbu_reg Addr: $addr = [format %x $ret]"
	}
	return $ret
}

# Helper function to write a register within a DBU
proc write_dbu_reg { tap addr data } {
	irscan $tap 0x05
	drscan $tap 40 [expr "($data << 8) | $addr | 0x01"]
}

# Helper function which open the dbu tap
proc open_dbus { } {
	#  reset
	adapter assert srst
	sleep 200
	adapter assert trst
	sleep 200
	adapter deassert trst
	sleep 200
	adapter deassert srst

	# Switch from TMC to DBUs
	jtag tapdisable stih418.tmc

	# Reset srst
	adapter assert srst
	sleep 200
	adapter deassert srst

	# Enable DBU+SWITCHABLE on DBU and DBU_SA | DAP on DBU_SA
	write_dbu_reg stih418.dbu 0xC0 [expr "$::DBU_DBU | $::DBU_SWITCHABLE"]
	write_dbu_reg stih418.dbu-sa 0xC0 [expr $::DBU_SA_DBU_SA]

	# Abort connect if ID CODE do not match
	if {[read_dbu_reg stih418.dbu 0x08] != $::DBU_IDCODE} {
		echo "Detected DBU ID code not matching - ABORT"
		return -1
	}
	if {[read_dbu_reg stih418.dbu-sa 0x08] != $::DBU_SA_IDCODE} {
		echo "Detected DBU ID code not matching - ABORT"
		return -1
	}
}

# Start A9 debug
proc start_a9 { addr } {
	set CORESIGHT_DBGDSCR	0x088
	set CORESIGHT_DBGDRCR	0x090
	set CORESIGHT_DBGPRSR	0x314
	set CORESIGHT_DBGLAR	0xFB0

	# Unlock access (DBGLAR)
	write_memory [expr "$addr + $CORESIGHT_DBGLAR"] 32 0xC5ACCE55

	# Enable halting mode debug (DBGDSCR)
	write_memory [expr "$addr + $CORESIGHT_DBGDSCR"] 32 [expr "[read_memory [expr "$addr + $CORESIGHT_DBGDSCR"] 32 1] | (1 << 14)"]

	sleep 100

	# Set Halt Request Bit (0) in DRCR - when core non-debug logic reset is deasserted, debug mode is entered
	write_memory [expr "$addr + $CORESIGHT_DBGDRCR"] 32 [expr "[read_memory [expr "$addr + $CORESIGHT_DBGDRCR"] 32 1] | 0x01"]
}

## Load and Start the BTFWM
proc btfwm_load { path_btfwm } {
	set BTFWM_PARAM_LOAD_ADDR	0x6040000

	targets stih418.dbu_mem

	load_image $path_btfwm/btfmw-h418.elf
	load_image $path_btfwm/btfmw_params-b2264stxh418rev1.bin $BTFWM_PARAM_LOAD_ADDR
}

proc btfwm_run { } {
	# BTFWM load addr
	set BTFWM_PARAM_LOAD_ADDR	0x6040000
	set BTFWM_COMM_CHANNEL	0x6050000
	# BTFJ
	set BTFWM_HANDSHAKE		0x4254464A

	set A9_RESET_VECTOR_ABAP	0x0877F020
	set CORE_SYSCFG_A9_BOOT_CONF	0x092B01A0
	set CORE_SYSCFG_A9_SOFT_RESET	0x092B0200

	targets stih418.dbu_mem

	# Indicating JTAG mode with handshake between modules execution"
	write_memory $BTFWM_PARAM_LOAD_ADDR 32 $BTFWM_HANDSHAKE

	# Clear communication channel with firmware
	write_memory $BTFWM_COMM_CHANNEL 32 0x0

	# To be sure that a9 are hold under reset (2) a9_wdg (1) a9_hardreset
	write_memory $CORE_SYSCFG_A9_SOFT_RESET 32 [expr "[read_memory $CORE_SYSCFG_A9_SOFT_RESET 32 1] & 0x02"]
  write_memory $CORE_SYSCFG_A9_SOFT_RESET 32 [expr "[read_memory $CORE_SYSCFG_A9_SOFT_RESET 32 1] & 0x03 | 0x02"]

	# Configure A9 to boot at 0xFFFF0000
	write_memory $CORE_SYSCFG_A9_BOOT_CONF 32 [expr "[read_memory $CORE_SYSCFG_A9_BOOT_CONF 32 1] | 0x01"]

	# ABAP setup with ELF start address
	write_memory [expr "$A9_RESET_VECTOR_ABAP"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0x4"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0x8"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0xC"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0x10"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0x14"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0x18"] 32 0x6000148
	write_memory [expr "$A9_RESET_VECTOR_ABAP + 0x1C"] 32 0x6000148

	# Communication channel with firmware
	write_memory $BTFWM_COMM_CHANNEL 32 0x0

	# Release A9 reset
	write_memory $CORE_SYSCFG_A9_SOFT_RESET 32 [expr "[read_memory $CORE_SYSCFG_A9_SOFT_RESET 32 1] & 0x02 | 0x01"]

	# Behavior from function fw_exec_v2 in btfmw.py from targetpack package
	set i 1
	set stage { 1 "BTFWM start" 2 "BTFWM init" 3 "Configuring AVS" 4 "Configuring Clock" 5 "Configuring SFC" 6 "Configuring DDR" 7 "Configuring Interco" 8 "Configuring EMI" 9 "BTFWM exit" }
	while {$i < 10} {
		# No EMI configuration needed
		if {$i == 8} {
			set i [expr "$i + 1"]
			continue
		}

		if {$i > 2} {
			# Wait for previous message to be read by FW
			while {1} {
				set ack [read_memory $BTFWM_COMM_CHANNEL 32 1]
				if {[expr "$ack & 0x000f0000"] == 0} {
					break
				}
			}

			# Send the message to the FW
			write_memory $BTFWM_COMM_CHANNEL 32 [expr "(0xcafe << 16) | ($i - 1)"]
		}

		while {1} {
			set ack [read_memory $BTFWM_COMM_CHANNEL 32 1]
			if {[expr "$ack & 0xffff0000"] == 0xfade0000} {
				break
			}
		}
		set ack [read_memory $BTFWM_COMM_CHANNEL 32 1]
		set fw_error [expr "$ack & 0xff"]
		set fw_error2 [expr "($ack >> 8) & 0xff"]
		write_memory $BTFWM_COMM_CHANNEL 32 [expr "$ack & 0xfff00000"]

		if {$fw_error != 0} {
			echo "$stage($i): Failed - ERROR $fw_error:$fw_error2"
		} else {
			echo "$stage($i): OK"
		}

		set i [expr "$i + 1"]
	}
}

# Identification of the chip / mode-pins
proc start_boot { path_btfwm } {
	# Rely on the DBU access
	targets stih418.dbu_mem

	# Disable IC auto clock gating
	write_memory 0x092c00a8 32 0x0224080C

	# Chip identification addresses
	set SBC_SYSCFG_DEVICE_ID 0x0960084C
	set STIH418_DEV_ID_MINOR 0x08A6583C
	set STIH418_DEV_ID 0x0D45A041

	# Sysconfig
	set CORE_SYSCFG_A9_SOFT_RESET 0x092B0200

	set id [read_memory $SBC_SYSCFG_DEVICE_ID 32 1]
	if { [expr "$id & 0x0fffffff"] != $STIH418_DEV_ID } {
		echo "Detected SOC is not a STiH418, abort"
		return -1
	}

	echo "STiH418 cut [format %d.%d [expr "(($id >> 28) & 0x0F) + 1"] [expr "[read_memory $STIH418_DEV_ID_MINOR 32 1] & 0x0F"]] detected"

	# Perform BTFWM handling
	btfwm_load $path_btfwm
	btfwm_run

	# Postpoke stage & enabling of the DAP
	# Ensure A9 is hold under reset
	write_memory $CORE_SYSCFG_A9_SOFT_RESET 32 [expr "[read_memory $CORE_SYSCFG_A9_SOFT_RESET 32 1] & 0x02"]
	write_memory $CORE_SYSCFG_A9_SOFT_RESET 32 [expr "[read_memory $CORE_SYSCFG_A9_SOFT_RESET 32 1] & 0x03 | 0x02"]

	# Perform trstn for all cores
	# Access to register 0xe0 (DBU_CPU_NTRST) using both DBUs (read)
	write_dbu_reg stih418.dbu 0xE0 0xFFFFF001
	write_dbu_reg stih418.dbu-sa 0xE0 0xFFFFFFFB

	sleep 100

	write_dbu_reg stih418.dbu 0xE0 0xFFFFFFFF
	write_dbu_reg stih418.dbu-sa 0xE0 0xFFFFFFFF

	sleep 100

	# Set CPU into debug mode
	# Reset pulse on A9 coresight logic
	# Access to register 0xE4 (DBU_CPU_DEBUG_EN)
	write_dbu_reg stih418.dbu 0xE4 0x00000010
	write_dbu_reg stih418.dbu-sa 0xE4 0x00000000

	sleep 100

	write_dbu_reg stih418.dbu 0xE4 0x00000000
	write_dbu_reg stih418.dbu-sa 0xE4 0x00000000

	# Start A9 boot sequence (Core 0)
	start_a9 0x08728000
	start_a9 0x0872a000
	start_a9 0x08730000
	start_a9 0x08732000

	# Hard reset_n = 1
	write_memory $CORE_SYSCFG_A9_SOFT_RESET 32 [expr "[read_memory $CORE_SYSCFG_A9_SOFT_RESET 32 1] | 0x01"]

	# Enable DBU & A9 TAP
	write_dbu_reg stih418.dbu 0xC0 [expr "$::DBU_DBU | $::DBU_SWITCHABLE"]
	write_dbu_reg stih418.dbu-sa 0xC0 [expr "$::DBU_SA_A9"]

	jtag tapdisable stih418.dbu-sa
	jtag tapenable stih418.dbu-dap
}

proc debug_cold { path_btfwm } {
	# Open access to the DBUs
	open_dbus
	# Proceed with boot
	start_boot $path_btfwm
}

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stih418
}

if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
	set _CPUTAPID 0x0d45a041
}

set _TARGETNAME $_CHIPNAME.cpu

jtag newtap $_CHIPNAME tmc -irlen 5 -expected-id $_CPUTAPID
# To disable the TMC tap and give access to the other TAP (DBUs etc)
# we need to perform an irscan on the TMC
jtag configure $_CHIPNAME.tmc -event tap-disable {
	irscan $::_CHIPNAME.tmc 0x10
	sleep 100
	jtag tapenable stih418.dbu
	jtag tapenable stih418.dbu-sa
	# Ack the DBUs flag registers
	irscan $::_CHIPNAME.dbu 0x04
	drscan $::_CHIPNAME.dbu 2 0x01
	irscan $::_CHIPNAME.dbu-sa 0x04
	drscan $::_CHIPNAME.dbu-sa 2 0x01
}

jtag newtap $_CHIPNAME dbu-dap -irlen 4 -expected-id 0x4ba00477 -disable
jtag configure $_CHIPNAME.dbu-dap -event tap-enable {}

jtag newtap $_CHIPNAME dbu-sa -irlen 3 -expected-id 0x18400d02 -disable
jtag configure $_CHIPNAME.dbu-sa -event tap-enable {}
jtag configure $_CHIPNAME.dbu-sa -event tap-disable {}

jtag newtap $_CHIPNAME dbu -irlen 3 -expected-id 0x24103d03 -disable
jtag configure $_CHIPNAME.dbu -event tap-enable {}
jtag configure $_CHIPNAME.dbu -event tap-disable {}

target create $_CHIPNAME.dbu_mem stdbu -chain-position $_CHIPNAME.dbu

dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.dbu-dap
target create $_CHIPNAME.cpu0 cortex_a -dap $_CHIPNAME.dap -coreid 0
target create $_CHIPNAME.cpu1 cortex_a -dap $_CHIPNAME.dap -coreid 1
target create $_CHIPNAME.cpu2 cortex_a -dap $_CHIPNAME.dap -coreid 2
target create $_CHIPNAME.cpu3 cortex_a -dap $_CHIPNAME.dap -coreid 3

$_CHIPNAME.cpu0  configure -event examine-start	{ dap init }
